<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>scDblFinder • scDblFinder</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="scDblFinder">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-dark" data-bs-theme="dark" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">scDblFinder</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.19.6</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="active nav-item"><a class="nav-link" href="../articles/scDblFinder.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/computeDoubletDensity.html">Scoring potential doublets from simulated densities</a></li>
    <li><a class="dropdown-item" href="../articles/findDoubletClusters.html">Detecting clusters of doublet cells with DE analyses</a></li>
    <li><a class="dropdown-item" href="../articles/introduction.html">Introduction to the scDblFinder package</a></li>
    <li><a class="dropdown-item" href="../articles/recoverDoublets.html">Recovering intra-sample doublets</a></li>
    <li><a class="dropdown-item" href="../articles/scATAC.html">Doublet identifiation in single-cell ATAC-seq</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/plger/scDblFinder/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>scDblFinder</h1>
                        <h4 data-toc-skip class="author">Pierre-Luc
Germain</h4>
            <address class="author_afil">
      University and ETH Zürich<br><small class="dont-index">Source: <a href="https://github.com/plger/scDblFinder/blob/devel/vignettes/scDblFinder.Rmd" class="external-link"><code>vignettes/scDblFinder.Rmd</code></a></small>
      <div class="d-none name"><code>scDblFinder.Rmd</code></div>
    </address>
</div>

    
        <div class="abstract">
      <p class="abstract">Abstract</p>
      <p>An introduction to the scDblFinder method for fast and
      comprehensive doublet identification in single-cell data.</p>
    </div>
    
<div class="section level2">
<h2 id="scdblfinder">scDblFinder<a class="anchor" aria-label="anchor" href="#scdblfinder"></a>
</h2>
<p>The <code>scDblFinder</code> method combines the strengths of various
doublet detection approaches, training an iterative classifier on the
neighborhood of real cells and artificial doublets.</p>
<p><code><a href="../reference/scDblFinder.html">scDblFinder()</a></code> has two main modes of operation:
cluster-based or not. Both perform quite well (see <a href="https://f1000research.com/articles/10-979" class="external-link">Germain et al.,
2021</a>). In general, we recommend the cluster-based approach in
datasets with a very clear cluster structure, and the random approach in
more complex datasets.</p>
<div class="section level3">
<h3 id="installation">Installation<a class="anchor" aria-label="anchor" href="#installation"></a>
</h3>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw">if</span> <span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/ns-load.html" class="external-link">requireNamespace</a></span><span class="op">(</span><span class="st">"BiocManager"</span>, quietly <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/utils/install.packages.html" class="external-link">install.packages</a></span><span class="op">(</span><span class="st">"BiocManager"</span><span class="op">)</span></span>
<span><span class="fu">BiocManager</span><span class="fu">::</span><span class="fu"><a href="https://bioconductor.github.io/BiocManager/reference/install.html" class="external-link">install</a></span><span class="op">(</span><span class="st">"scDblFinder"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># or, to get that latest developments:</span></span>
<span><span class="fu">BiocManager</span><span class="fu">::</span><span class="fu"><a href="https://bioconductor.github.io/BiocManager/reference/install.html" class="external-link">install</a></span><span class="op">(</span><span class="st">"plger/scDblFinder"</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="usage">Usage<a class="anchor" aria-label="anchor" href="#usage"></a>
</h3>
<p>The input of <code>scDblFinder</code> is an object <code>sce</code>
of class <em><a href="https://bioconductor.org/packages/3.19/SingleCellExperiment" class="external-link">SingleCellExperiment</a></em>
(empty drops having already been removed) containing at least the counts
(assay ‘counts’). Alternatively, a simple count matrix can also be
provided.</p>
<p>Given an SCE object, <code>scDblFinder</code> (using the random
approach) can be launched as follows :</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/message.html" class="external-link">suppressPackageStartupMessages</a></span><span class="op">(</span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/plger/scDblFinder" class="external-link">scDblFinder</a></span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co"># we create a dummy dataset; since it's small we set a higher doublet rate</span></span>
<span><span class="va">sce</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mockDoubletSCE.html">mockDoubletSCE</a></span><span class="op">(</span>dbl.rate<span class="op">=</span><span class="fl">0.1</span>, ngenes<span class="op">=</span><span class="fl">300</span> <span class="op">)</span></span>
<span><span class="co"># we run scDblFinder (providing the unusually high doublet rate)</span></span>
<span><span class="va">sce</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/scDblFinder.html">scDblFinder</a></span><span class="op">(</span><span class="va">sce</span>, dbr<span class="op">=</span><span class="fl">0.1</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Creating ~1500 artificial doublets...</span></span></code></pre>
<pre><code><span><span class="co">## Dimensional reduction</span></span></code></pre>
<pre><code><span><span class="co">## Evaluating kNN...</span></span></code></pre>
<pre><code><span><span class="co">## Training model...</span></span></code></pre>
<pre><code><span><span class="co">## iter=0, 38 cells excluded from training.</span></span></code></pre>
<pre><code><span><span class="co">## iter=1, 25 cells excluded from training.</span></span></code></pre>
<pre><code><span><span class="co">## iter=2, 25 cells excluded from training.</span></span></code></pre>
<pre><code><span><span class="co">## Threshold found:0.326</span></span></code></pre>
<pre><code><span><span class="co">## 28 (5.3%) doublets called</span></span></code></pre>
<p>For 10x data, it is usually safe to leave the <code>dbr</code> empty,
and it will be automatically estimated. (If using a chip other than the
standard 10X, you might have to adjust it or the related
<code>dbr.per1k</code> argument.</p>
<p><code>scDblFinder</code> will add a number of columns to the colData
of <code>sce</code> prefixed with ‘scDblFinder’, the most important of
which are:</p>
<ul>
<li>
<code>sce$scDblFinder.score</code> : the final doublet score</li>
<li>
<code>sce$scDblFinder.class</code> : the classification (doublet or
singlet)</li>
</ul>
<p>We can compare the calls with the truth in this toy example:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/BiocGenerics/man/table.html" class="external-link">table</a></span><span class="op">(</span>truth<span class="op">=</span><span class="va">sce</span><span class="op">$</span><span class="va">type</span>, call<span class="op">=</span><span class="va">sce</span><span class="op">$</span><span class="va">scDblFinder.class</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##          call</span></span>
<span><span class="co">## truth     singlet doublet</span></span>
<span><span class="co">##   singlet     496       4</span></span>
<span><span class="co">##   doublet       0      24</span></span></code></pre>
<p>To use the <em>cluster-based</em> approach, one simply needs to
additionally provide the <code>clusters</code> argument:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sce</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/scDblFinder.html">scDblFinder</a></span><span class="op">(</span><span class="va">sce</span>, clusters<span class="op">=</span><span class="st">"cluster"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## 2 clusters</span></span></code></pre>
<pre><code><span><span class="co">## Creating ~1500 artificial doublets...</span></span></code></pre>
<pre><code><span><span class="co">## Dimensional reduction</span></span></code></pre>
<pre><code><span><span class="co">## Evaluating kNN...</span></span></code></pre>
<pre><code><span><span class="co">## Training model...</span></span></code></pre>
<pre><code><span><span class="co">## iter=0, 24 cells excluded from training.</span></span></code></pre>
<pre><code><span><span class="co">## iter=1, 24 cells excluded from training.</span></span></code></pre>
<pre><code><span><span class="co">## iter=2, 24 cells excluded from training.</span></span></code></pre>
<pre><code><span><span class="co">## Threshold found:0.998</span></span></code></pre>
<pre><code><span><span class="co">## 24 (4.6%) doublets called</span></span></code></pre>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/BiocGenerics/man/table.html" class="external-link">table</a></span><span class="op">(</span>truth<span class="op">=</span><span class="va">sce</span><span class="op">$</span><span class="va">type</span>, call<span class="op">=</span><span class="va">sce</span><span class="op">$</span><span class="va">scDblFinder.class</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##          call</span></span>
<span><span class="co">## truth     singlet doublet</span></span>
<span><span class="co">##   singlet     500       0</span></span>
<span><span class="co">##   doublet       0      24</span></span></code></pre>
<p>The <code>clusters</code> argument can be either a vector of cluster
labels for each column of <code>sce</code>, a colData column of
<code>sce</code> containing such labels, or <code>TRUE</code>. If
<code>clusters=TRUE</code>, the fast clustering approach (see
<code><a href="../reference/fastcluster.html">?fastcluster</a></code>) will be employed. If normalized expression
(assay ‘logcounts’) and/or PCA (reducedDim ‘PCA’) are already present in
the object, these will be used for the clustering step.</p>
<div class="section level4">
<h4 id="multiple-samples">Multiple samples<a class="anchor" aria-label="anchor" href="#multiple-samples"></a>
</h4>
<p>If you have multiple samples (understood as different cell captures),
then it is preferable to look for doublets separately for each sample
(for multiplexed samples with cell hashes, this means for each batch).
You can do this by simply providing a vector of the sample ids to the
<code>samples</code> parameter of <code>scDblFinder</code> or, if these
are stored in a column of <code>colData</code>, the name of the column.
In this case, you might also consider multithreading it using the
<code>BPPARAM</code> parameter (assuming you’ve got enough RAM!). For
example:</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/Bioconductor/BiocParallel" class="external-link">BiocParallel</a></span><span class="op">)</span></span>
<span><span class="va">sce</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/scDblFinder.html">scDblFinder</a></span><span class="op">(</span><span class="va">sce</span>, samples<span class="op">=</span><span class="st">"sample_id"</span>, BPPARAM<span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/MulticoreParam-class.html" class="external-link">MulticoreParam</a></span><span class="op">(</span><span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/BiocGenerics/man/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">sce</span><span class="op">$</span><span class="va">scDblFinder.class</span><span class="op">)</span></span></code></pre></div>
<p>Note that if you are running multiple samples using the cluster-based
approach (see below), clustering will be performed sample-wise. While
this is typically not an issue for doublet identification, it means that
the cluster labels (and putative origins of doublets) won’t match
between samples. If you are interested in these, it is preferable to
first cluster (for example using
<code>sce$cluster &lt;- fastcluster(sce)</code>) and then provide the
clusters to <code>scDblFinder</code>, which will ensure concordant
labels across samples.</p>
<p>Of note, if you have very large differences in number of cells
between samples the scores will not be directly comparable. We are
working on improving this, but in the meantime it would be preferable to
stratify similar samples and threshold the sets separately.</p>
<p><br><br></p>
</div>
</div>
<div class="section level3">
<h3 id="description-of-the-method">Description of the method<a class="anchor" aria-label="anchor" href="#description-of-the-method"></a>
</h3>
<p>Wrapped in the <code>scDblFinder</code> function are the following
steps:</p>
<div class="section level4">
<h4 id="splitting-captures">Splitting captures<a class="anchor" aria-label="anchor" href="#splitting-captures"></a>
</h4>
<p>Doublets can only arise within a given sample or capture, and for
this reason are better sought independently for each sample, which also
speeds up the analysis. If the <code>samples</code> argument is given,
<code>scDblFinder</code> will use it to split the cells into
samples/captures, and process each of them in parallel if the
<code>BPPARAM</code> argument is given. Depending on the
<code>multiSampleMode</code> argument, the classifier can be trained
globally, with thresholds optimized on a per-sample basis; however we
did not see an improvement in doing so, and therefore by default each
sample is treated separately to maximize robustness to technical
differences.</p>
<p>If your samples are multiplexed, i.e. the different samples are mixed
in different batches, then the batches should be what you provide to
this argument.</p>
</div>
<div class="section level4">
<h4 id="reducing-and-clustering-the-data">Reducing and clustering the data<a class="anchor" aria-label="anchor" href="#reducing-and-clustering-the-data"></a>
</h4>
<p>The analysis can be considerably sped up, at little if any cost in
accuracy, by reducing the dataset to only the top expressed genes
(controlled by the <code>nfeatures</code> argument).</p>
<p>Then, depending on the <code>clusters</code> argument, an eventual
PCA and clustering (using the internal <code>fastcluster</code>
function) will be performed. The rationale for the cluster-based
approach is that homotypic doublets are nearly impossible to distinguish
on the basis of their transcriptome, and therefore that creating that
kind of doublets is a waste of computational resources that can moreover
mislead the classifier into flagging singlets. An alternative approach,
however, is to generate doublets randomly (setting <code>clusters</code>
to FALSE or NULL), and use the iterative approach (see below) to exclude
also unidentifiable artificial doublets from the training.</p>
</div>
<div class="section level4">
<h4 id="generating-artificial-doublets">Generating artificial doublets<a class="anchor" aria-label="anchor" href="#generating-artificial-doublets"></a>
</h4>
<p>Depending on the <code>clusters</code> and <code>propRandom</code>
arguments, artificial doublets will be generated by combining random
cells and/or pairs of non-identical clusters (this can be performed
manually using the <code>getArtificialDoublets</code> function). A
proportion of the doublets will simply use the sum of counts of the
composing cells, while the rest will undergo a library size adjustment
and poisson resampling.</p>
</div>
<div class="section level4">
<h4 id="examining-the-k-nearest-neighbors-knn-of-each-cell">Examining the k-nearest neighbors (kNN) of each cell<a class="anchor" aria-label="anchor" href="#examining-the-k-nearest-neighbors-knn-of-each-cell"></a>
</h4>
<p>A new PCA is performed on the combination of real and artificial
cells, from which a kNN network is generated. Using this kNN, a number
of parameters are gathered for each cell, such as the proportion of
doublets (i.e. artificial doublets or known doublets provided through
the <code>knownDoublets</code> argument, if given) among the KNN, ratio
of the distances to the nearest doublet and nearest non-doublet, etc.
Several of this features are reported in the output with the
‘scDblFinder.’ prefix, e.g.:</p>
<ul>
<li>
<code>distanceToNearest</code> : distance to the nearest cell (real
or artificial)</li>
<li>
<code>ratio</code> : the proportion of the KNN that are doublets.
(If more than one value of <code>k</code> is given, the various ratios
will be used during classification and will be reported)</li>
<li>
<code>weighted</code> : the proportion of the KNN that are doublets,
weighted by their distance (useful for isolated cells)</li>
</ul>
</div>
<div class="section level4">
<h4 id="training-a-classifier">Training a classifier<a class="anchor" aria-label="anchor" href="#training-a-classifier"></a>
</h4>
<p>Unless the <code>score</code> argument is set to ‘weighted’ or
‘ratio’ (in which case the aforementioned ratio is directly used as a
doublet score), <code>scDblFinder</code> then uses gradient boosted
trees trained on the kNN-derived properties along with a few additional
features (e.g. library size, number of non-zero features, and an
estimate of the difficultly of detecting artificial doublets in the
cell’s neighborhood, a variant of the <code>cxds</code> score from the
<em><a href="https://bioconductor.org/packages/3.19/scds/vignettes/scds" class="external-link">scds</a></em>,
etc.) to distinguish doublets (either artificial or given) from other
cells, and assigns a score on this basis.</p>
<p>One problem of using a classifier for this task is that some of the
real cells (the actual doublets) are mislabeled as singlet, so to speak.
<code>scDblFinder</code> therefore iteratively retrains the classifier,
each time excluding from the training the (real) cells called as
doublets in the previous step (as well as unidentifiable artificial
doublets). The number of steps being controlled by the <code>iter</code>
parameter (in our experience, 2 or 3 is optimal).</p>
<p>This score is available in the output, in the
<code>scDblFinder.score</code> colData column, and can be interpreted as
a probability. If the data is multi-sample, a single model is trained
for all samples.</p>
</div>
<div class="section level4">
<h4 id="thresholding">Thresholding<a class="anchor" aria-label="anchor" href="#thresholding"></a>
</h4>
<p>Rather than thresholding on some arbitrary cutoff of the score,
<code>scDblFinder</code> uses the expected number of doublets in
combination to the misclassification rate to establish a threshold.
Unless it is manually given through the <code>dbr</code> argument, the
expected doublet rate is first estimated (see below). If samples were
specified, and if the <code>dbr</code> is automatically calculated,
thresholding is performed separately across samples.</p>
<p>Thresholding then tries to simultaneously minimize: 1) the
classification error (in terms of the proportion of known doublets below
the threshold) and 2) the deviation from the expected number of doublets
among real cells (as a ratio of the total number of expected doublets
within the range determined by <code>dbr.sd</code>, and adjusted for
homotypic doublets). This means that, if you have no idea about the
doublet rate, setting <code>dbr.sd=1</code> will make the threshold
depend entirely on the misclassification rate.</p>
</div>
<div class="section level4">
<h4 id="doublet-origins-and-enrichments">Doublet origins and enrichments<a class="anchor" aria-label="anchor" href="#doublet-origins-and-enrichments"></a>
</h4>
<p>If artificial doublets are generated between clusters, it is
sometimes possible to call the most likely origin (in terms of the
combination of clusters) of a given putative real doublet. We observed
that at least one of the two composing cell is typically recognized, but
that both are seldom correctly recognized, owing to the sometimes small
relative contribution of one of the two original cells. This information
is provided through the <code>scDblFinder.mostLikelyOrigin</code> column
of the output (and the <code>scDblFinder.originAmbiguous</code> column
indicates whether this origin is ambiguous or rather clear). This, in
turn, allows us to identify enrichment over expectation for specific
kinds of doublets. Some statistics on each combination of clusters are
saved in <code>metadata(sce)$scDblFinder.stats</code>, and the
<code>plotDoubletMap</code> function can be used to visualize
enrichments. In addition, two frameworks are offered for testing the
significance of enrichments:</p>
<ul>
<li>The <code>clusterStickiness</code> function tests whether each
cluster forms more doublet than would be expected given its abundance,
by default using a single quasi-binomial model fitted across all doublet
types.</li>
<li>The <code>doubletPairwiseEnrichment</code> function separately tests
whether each specific doublet type (i.e. combination of clusters) is
more abundant than expected, by default using a poisson model.</li>
</ul>
<p><br><br></p>
</div>
</div>
<div class="section level3">
<h3 id="some-important-parameters">Some important parameters<a class="anchor" aria-label="anchor" href="#some-important-parameters"></a>
</h3>
<p><code>scDblFinder</code> has a fair number of parameters governing
the preprocessing, generation of doublets, classification, etc. (see
<code><a href="../reference/scDblFinder.html">?scDblFinder</a></code>). Here we describe just a few of the most
important ones.</p>
<div class="section level4">
<h4 id="expected-proportion-of-doublets">Expected proportion of doublets<a class="anchor" aria-label="anchor" href="#expected-proportion-of-doublets"></a>
</h4>
<p>The expected proportion of doublets has no impact on the density of
artificial doublets in the neighborhood, but impacts the classifier’s
score and, especially, where the cutoff will be placed. It is specified
through the <code>dbr</code> parameter, as well as the
<code>dbr.per1k</code> (specifies, if <code>dbr</code> is omitted, the
rate per thousands cells from which to estimate it) and
<code>dbr.sd</code> parameters (the latter specifies a +/- range around
<code>dbr</code> within which the deviation from <code>dbr</code> will
be considered null).</p>
<p>For most platforms, the more cells you capture the higher the chance
of creating a doublet. For standard 10X data, the 10X documentation
indicates a doublet rate of roughly 0.8% per 1000 cells captured, which
is the default value of <code>dbr.per1k</code>. This means that unless
<code>dbr</code> is manually set, with 5000 cells, (0.008*5)*5000 = 200
doublets are expected, and the default expected doublet rate will be set
to this value (with a default standard deviation of 0.015). Note however
that different protocols may vary in the expected proportion of
doublets. For example, the high-throughput (HT) 10X kit has an expected
doublet rate of half the standard, i.e. 0.4% per 1000 cells, so if using
that kit, set <code>dbr.per1k=0.004</code>.</p>
<p>Also note that strictly speaking, the proportion of doublets depends
more on the number of cells inputted than that recovered. If your
recovery rate was lower than expected, you might observe a higher
doublet rate (see the <a href="#toomany">too-many doublets</a> section
below).</p>
<p>The impact of the expected doublet rate on the thresholding will
depend on how hard the classification task is: if it is easy, the called
doublets will not depend much on the expected rate. If you have unsure
about the doublet rate, you might consider increasing
<code>dbr.sd</code>, so that it is estimated mostly (or even purely)
from the misclassification error.</p>
</div>
<div class="section level4">
<h4 id="number-of-artificial-doublets">Number of artificial doublets<a class="anchor" aria-label="anchor" href="#number-of-artificial-doublets"></a>
</h4>
<p>The number of artificial doublets can be set through the
<code>artificialDoublets</code> parameter. Using more artificial
doublets leads to a better sampling of the possible mixtures of cells,
but increases memory and runtime, and can skew the scores, in extreme
cases leading to difficulties in setting a threshold for being called as
a doublet (see <a href="https://github.com/plger/scDblFinder/issues/79" class="external-link">this issue</a> for
a discussion).</p>
<p>By default, <code>scDblFinder</code> will generate roughly as many
artificial doublets as there are cells, which is usually appropriate.
However, for very small datasets this could represent an undersampling
of the mixing space and hence lead to lower detection accuracy. For this
reason, a hard minimum number of artificial doublet is set. This will
tend to improve accuracy for small datasets, but the scores will be
skewed towards 1, possibly making a separation difficult. If you are in
such a situation and your histogram of scores does not show a
bimodality, consider manually setting the
<code>artificialDoublets</code> parameter to something closer to your
actual number of cells.</p>
<p><br><br></p>
</div>
</div>
<div class="section level3">
<h3 id="frequently-asked-questions">Frequently-asked questions<a class="anchor" aria-label="anchor" href="#frequently-asked-questions"></a>
</h3>
<div class="section level4">
<h4 id="toomany">I’m getting way too many doublets called - what’s going on?<a class="anchor" aria-label="anchor" href="#toomany"></a>
</h4>
<p>Then you most likely have a wrong doublet rate. If you did not
provide it (<code>dbr</code> argument), the doublet rate will be
calculated automatically using expected doublet rates from 10x, meaning
that the more cells captured, the higher the doublet rates. If you have
reasons to think that this is not applicable to your data, set the
<code>dbr</code> manually.</p>
<p>The most common cause for an unexpectedly large proportion of
doublets is if you have a multi-sample dataset and did not split by
samples. <code>scDblFinder</code> will think that the data is a single
capture with loads of cells, and hence with a very high doublet rate.
Splitting by sample should solve the issue.</p>
<p>Also note that, although 10X-like data tends to have roughly 1% per
1000 cells captured, the determining factor for doublet formation is the
number of cells inserted into the machine. If for some reason your
recovery rate is lower than expected, you might have a higher doublet
rate than you’d expect from the captured and called cells (in other
words, it would be preferable to say that the doublet rate is roughly
0.6% per 1000 cells put into the machine, where 0.6 is the recovery
rate). In such circumstances, <code>scDblFinder</code> typically sets
the thresholds correctly nevertheless. This is because the thresholding
tries to minimize both the deviation from the expected number of
doublets and the misclassification (i.e. of artificial doublets),
meaning that the effective (i.e. final) doublet rate will differ from
the given one. <code>scDblFinder</code> also considers false positives
to be less problematic than false negatives. You can reduce to some
degree the deviation from the input doublet rate by setting
<code>dbr.sd=0</code>.</p>
</div>
<div class="section level4">
<h4 id="should-i-use-the-cluster-based-doublet-generation-or-not">Should I use the cluster-based doublet generation or not?<a class="anchor" aria-label="anchor" href="#should-i-use-the-cluster-based-doublet-generation-or-not"></a>
</h4>
<p>Both approaches perform very similarly overall in benchmarks (see the
<a href="https://f1000research.com/articles/10-979/" class="external-link">scDblFinder
paper</a>). If your data is very clearly segregated into clusters, or if
you are interested in the origin of the doublets, the cluster-based
approach is preferable. This will also enable a more accurate accounting
of homotypic doublets, and therefore a slightly better thresholding.
Otherwise, and especially if your data does not segregate very clearly
into clusters, the random approach (e.g. <code>clusters=FALSE</code>,
the default) is preferable.</p>
</div>
<div class="section level4">
<h4 id="the-clusters-dont-make-any-sense">The clusters don’t make any sense!<a class="anchor" aria-label="anchor" href="#the-clusters-dont-make-any-sense"></a>
</h4>
<p>If you ran <code>scDblFinder</code> on a multi-sample dataset and did
not provide the cluster labels, then the labels are sample-specific
(meaning that label ‘1’ in one sample might have nothing to do with
label ‘1’ in another), and plotting them on a tSNE will look like they
do not make sense. For this reason, when running multiple samples we
recommend to first cluster all samples together (for example using
<code>sce$cluster &lt;- fastcluster(sce)</code>) and then provide the
clusters to <code>scDblFinder</code>.</p>
</div>
<div class="section level4">
<h4 id="size-factors-should-be-positive-error">‘Size factors should be positive’ error<a class="anchor" aria-label="anchor" href="#size-factors-should-be-positive-error"></a>
</h4>
<p>You will get this error if you have some cells that have zero reads
(or a very low read count, leading to zero after feature selection).
After filtering out these cells the error should go away.</p>
</div>
<div class="section level4">
<h4 id="identifying-homotypic-doublets">Identifying homotypic doublets<a class="anchor" aria-label="anchor" href="#identifying-homotypic-doublets"></a>
</h4>
<p>Like other similar tools, scDblFinder focuses on identifying
heterotypic doublets (formed by different cell types), and has only a
low performance in identifying homotypic doublets (see <a href="https://doi.org/10.1101/2023.08.04.552078" class="external-link">this preprint</a>).
This can lead to disagreements with doublets called using cell hashes or
SNPs in multiplexed samples, which capture both types of doublets
similarly (and can miss intra-sample heterotypic doublets, especially if
the multiplexing is low). This is why we treat these approaches as
complementary.</p>
<p>However, should you for some reason try to identify also homotypic
doublets with scDblFinder, be sure to not to use the cluster-based
approach, and to set <code>removeUnidentifiable=FALSE</code>. Otherwise,
scDblFinder removes artificial doublets likely to be homotypic from
training, therefore focusing the task on heterotypic doublets, but at
the expense ot homotypic ones (which are typically deemed relatively
harmless).</p>
</div>
<div class="section level4">
<h4 id="how-can-i-make-this-reproducible">How can I make this reproducible?<a class="anchor" aria-label="anchor" href="#how-can-i-make-this-reproducible"></a>
</h4>
<p>Because it relies on the partly random generation of artificial
doublets, running scDblFinder multiple times on the same data will yield
slightly different results. You can ensure reproducibility using
<code><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed()</a></code>, however this will not be sufficient when
processing multiple samples (i.e. using the <code>samples</code>
argument – even without multithreading!). In such case, the seed needs
to be passed to the BPPARAMs:</p>
<pre><code><span><span class="va">bp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/BiocParallel/man/MulticoreParam-class.html" class="external-link">MulticoreParam</a></span><span class="op">(</span><span class="fl">3</span>, RNGseed<span class="op">=</span><span class="fl">1234</span><span class="op">)</span></span>
<span><span class="va">sce</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/scDblFinder.html">scDblFinder</a></span><span class="op">(</span><span class="va">sce</span>, clusters<span class="op">=</span><span class="st">"cluster"</span>, samples<span class="op">=</span><span class="st">"sample"</span>, BPPARAM<span class="op">=</span><span class="va">bp</span><span class="op">)</span></span></code></pre>
<p>Similarly, when processing the samples serially, use
<code>SerialParam(RNGseed = seed)</code>.</p>
<p>(Note that in <code>BiocParallel</code> versions &lt;1.28, one had in
addition to explicitly start the cluster before the run using
<code>bpstart(bp)</code>, and then <code>bpstop(bp)</code> after
<code>scDblFinder</code>.)</p>
<p>As a final note: when running <code>scDblFinder</code> twice on the
same data with different random seeds, the scores will be highly
correlated, but some cells will be called as doublets (with a high
score) in only one of the runs (e.g. see <a href="https://github.com/plger/scDblFinder/issues/106" class="external-link">this issue</a>).
There are good reasons to believe that these are
<code>homotypic doublets</code> (if doublets at all), and if you worry
chiefly about hetertypic doublets, you may concentrate on those that are
reprocibly called across runs.</p>
</div>
<div class="section level4">
<h4 id="can-i-use-this-in-combination-with-seurat-or-other-tools">Can I use this in combination with Seurat or other tools?<a class="anchor" aria-label="anchor" href="#can-i-use-this-in-combination-with-seurat-or-other-tools"></a>
</h4>
<p>If the input SCE already contains a <code>logcounts</code> assay or a
<code>reducedDim</code> slot named ‘PCA’, scDblFinder will use them for
the clustering step. In addition, a clustering can be manually given
using the <code>clusters</code> argument of <code><a href="../reference/scDblFinder.html">scDblFinder()</a></code>.
In this way, <em><a href="https://github.com/satijalab.org/seurat" class="external-link">seurat</a></em>
clustering could for instance be used to create the artificial doublets
(see <code>?Seurat::as.SingleCellExperiment.Seurat</code> for conversion
to SCE). For example, assuming as <code>Seurat</code> object
<code>se</code>, the following could be done:</p>
<pre><code><span><span class="va">sce</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/scDblFinder.html">scDblFinder</a></span><span class="op">(</span><span class="fu">GetAssayData</span><span class="op">(</span><span class="va">se</span>, slot<span class="op">=</span><span class="st">"counts"</span><span class="op">)</span>, clusters<span class="op">=</span><span class="fu">Idents</span><span class="op">(</span><span class="va">se</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co"># port the resulting scores back to the Seurat object:</span></span>
<span><span class="va">se</span><span class="op">$</span><span class="va">scDblFinder.score</span> <span class="op">&lt;-</span> <span class="va">sce</span><span class="op">$</span><span class="va">scDblFinder.score</span></span></code></pre>
<p>After artificial doublets generation, the counts of real and
artificial cells must then be reprocessed (i.e. normalization and PCA)
together, which is performed internally using <em><a href="https://bioconductor.org/packages/3.19/scater" class="external-link">scater</a></em>. If
you wish this step to be performed differently, you may provide your own
function for doing so (see the <code>processing</code> argument in
<code><a href="../reference/scDblFinder.html">?scDblFinder</a></code>). We note, however, that the impact of
variations of this step on doublet detection is rather mild. In fact,
not performing any normalization at all for instance decreases doublet
identification accuracy, but by rather little.</p>
<p>For example, the following code would enable the internal use of <a href="https://github.com/satijalab/sctransform" class="external-link">sctransform</a>:</p>
<pre><code><span><span class="co"># assuming `x` is the count matrix:</span></span>
<span><span class="va">nfeatures</span> <span class="op">&lt;-</span> <span class="fl">1000</span></span>
<span><span class="va">sce</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/SingleCellExperiment/man/SingleCellExperiment.html" class="external-link">SingleCellExperiment</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>counts<span class="op">=</span><span class="va">x</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co"># sctransform on real cells:</span></span>
<span><span class="va">vst1</span> <span class="op">&lt;-</span> <span class="fu">sctransform</span><span class="fu">::</span><span class="fu">vst</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/BiocGenerics/man/dge.html" class="external-link">counts</a></span><span class="op">(</span><span class="va">sce</span><span class="op">)</span>, n_cells<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/BiocGenerics/man/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">sce</span><span class="op">)</span>,<span class="fl">5000</span><span class="op">)</span>, verbosity<span class="op">=</span><span class="fl">0</span><span class="op">)</span></span>
<span><span class="va">sce</span> <span class="op">&lt;-</span> <span class="va">sce</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/row.names.html" class="external-link">row.names</a></span><span class="op">(</span><span class="va">vst1</span><span class="op">$</span><span class="va">y</span><span class="op">)</span>,<span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/SingleCellExperiment/man/assays.html" class="external-link">logcounts</a></span><span class="op">(</span><span class="va">sce</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="va">vst1</span><span class="op">$</span><span class="va">y</span></span>
<span><span class="va">hvg</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/row.names.html" class="external-link">row.names</a></span><span class="op">(</span><span class="va">sce</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/BiocGenerics/man/order.html" class="external-link">order</a></span><span class="op">(</span><span class="va">vst1</span><span class="op">$</span><span class="va">gene_attr</span><span class="op">$</span><span class="va">residual_variance</span>, decreasing<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>, <span class="va">nfeatures</span><span class="op">)</span><span class="op">]</span></span>
<span></span>
<span><span class="co"># define a processing function that scDblFinder will use on the real+artificial doublets;</span></span>
<span><span class="co"># the input should be a count matrix and the number of dimensions, and the output a PCA matrix</span></span>
<span>  </span>
<span><span class="va">myfun</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">e</span>, <span class="va">dims</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="co"># we use the thetas calculated from the first vst on real cells</span></span>
<span>  <span class="va">e</span> <span class="op">&lt;-</span> <span class="va">e</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/pkg/BiocGenerics/man/sets.html" class="external-link">intersect</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/row.names.html" class="external-link">row.names</a></span><span class="op">(</span><span class="va">e</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/row.names.html" class="external-link">row.names</a></span><span class="op">(</span><span class="va">vst1</span><span class="op">$</span><span class="va">model_pars_fit</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/pkg/BiocGenerics/man/which.html" class="external-link">which</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">vst1</span><span class="op">$</span><span class="va">model_pars_fit</span><span class="op">[</span>,<span class="st">"theta"</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>,<span class="op">]</span><span class="op">)</span><span class="op">)</span>,<span class="op">]</span></span>
<span>  <span class="va">vst2</span> <span class="op">&lt;-</span> <span class="fu">sctransform</span><span class="fu">::</span><span class="fu">vst</span><span class="op">(</span><span class="va">e</span>, n_cells<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/BiocGenerics/man/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">e</span><span class="op">)</span>,<span class="fl">5000</span><span class="op">)</span>, method<span class="op">=</span><span class="st">"nb_theta_given"</span>, </span>
<span>                           theta_given<span class="op">=</span><span class="va">vst1</span><span class="op">$</span><span class="va">model_pars_fit</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/row.names.html" class="external-link">row.names</a></span><span class="op">(</span><span class="va">e</span><span class="op">)</span>,<span class="st">"theta"</span><span class="op">]</span>,</span>
<span>                           min_cells<span class="op">=</span><span class="fl">1L</span>, verbosity<span class="op">=</span><span class="fl">0</span><span class="op">)</span></span>
<span>  <span class="fu">scater</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/scater/man/runPCA.html" class="external-link">calculatePCA</a></span><span class="op">(</span><span class="va">vst2</span><span class="op">$</span><span class="va">y</span>, ncomponents<span class="op">=</span><span class="va">dims</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span>  </span>
<span><span class="va">sce</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/scDblFinder.html">scDblFinder</a></span><span class="op">(</span><span class="va">sce</span>, processing<span class="op">=</span><span class="va">myfun</span>, nfeatures<span class="op">=</span><span class="va">hvg</span><span class="op">)</span></span></code></pre>
<p>Note however that this did not generally lead to improved performance
– but rather decreased on most benchmark datasets, in fact (see <a href="https://user-images.githubusercontent.com/9786697/211782249-804aa42f-cc08-4e36-b59e-3c00a2b6f363.png" class="external-link">comparison</a>
in this <a href="https://github.com/plger/scDblFinder/issues/67#issuecomment-1378543321" class="external-link">issue</a>).</p>
</div>
<div class="section level4">
<h4 id="can-this-be-used-with-scatacseq-data">Can this be used with scATACseq data?<a class="anchor" aria-label="anchor" href="#can-this-be-used-with-scatacseq-data"></a>
</h4>
<p>Yes, see the <a href="scATAC.html">scATAC vignette</a> specifically
on this topic.</p>
</div>
<div class="section level4">
<h4 id="should-i-run-qc-cell-filtering-before-or-after-doublet-detection">Should I run QC cell filtering before or after doublet
detection?<a class="anchor" aria-label="anchor" href="#should-i-run-qc-cell-filtering-before-or-after-doublet-detection"></a>
</h4>
<p>The input to <code>scDblFinder</code> should not include empty
droplets, and it might be necessary to remove cells with a very low
coverage (e.g. &lt;200 or 500 reads) to avoid errors. Further quality
filtering should be performed <em>downstream</em> of doublet detection,
for two reasons: 1. the default expected doublet rate is calculated on
the basis of the cells given, and if you excluded a lot of cells as low
quality, <code>scDblFinder</code> might think that the doublet rate
should be lower than it is. 2. kicking out all low quality cells first
might hamper our ability to detect doublets that are formed by the
combination of a good quality cell with a low-quality one. This being
said, these are mostly theoretical grounds, and unless your QC filtering
is very stringent (and it shouldn’t be!), it’s unlikely to make a big
difference.</p>
<div class="section level5">
<h5 id="what-about-ambiant-rna-decontamination">What about ambiant RNA decontamination?<a class="anchor" aria-label="anchor" href="#what-about-ambiant-rna-decontamination"></a>
</h5>
<p>Contamination by ambiant RNA has emerged as an important confounder
in single-cell (and especially single-nuclei) RNAseq data, which prompts
the question of whether that should be run prior or after doublet
detection. Unfortunately, we do not currently have good evidence
pointing in either direction, and arguments can be made for both.
Low-quality doublets, or doublets from an experiment with a large
dominant celltype, can easily look like contamination, and likewise a
high amount of contamination can easily look like a doublet because it
includes RNA from other cell types. There is a possibility that a
decontamination package sees an actual doublet as contamination, and
attempts to clean it, which it will necessarily do imperfectly (because
while the decontamination is a mixture of all cells, a doublet isn’t),
but perhaps sufficiently so that it can’t be accurately detected as a
doublet anymore. This would therefore be an argument for running doublet
calling first. However, it’s also possible that decontamination, because
it makes the cells cleaner, makes the doublet detection task easier.</p>
</div>
</div>
<div class="section level4">
<h4 id="can-i-combine-this-method-with-others">Can I combine this method with others?<a class="anchor" aria-label="anchor" href="#can-i-combine-this-method-with-others"></a>
</h4>
<p>Of course it is always possible to run multiple methods and combine
the results. In our benchmark, the combination of scDblFinder with
DoubletFinder, for instance, did yield an improvement in most (though
not all) datasets (see <a href="https://github.com/plger/scDblFinder/issues/67#issuecomment-1353590091" class="external-link">the
results here</a>), although of a small magnitude. The simplest way is to
do an average of the scores (assuming that the scores are on a similar
scale, and that a higher score has the same interpretation across
methods), which for instance gave similar results to using a Fisher
p-value combination on 1-score (interpreted as a probability).</p>
</div>
</div>
</div>
<div class="section level2">
<h2 class="unnumbered" id="session-information">Session information<a class="anchor" aria-label="anchor" href="#session-information"></a>
</h2>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/sessionInfo.html" class="external-link">sessionInfo</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## R version 4.4.1 (2024-06-14)</span></span>
<span><span class="co">## Platform: x86_64-pc-linux-gnu</span></span>
<span><span class="co">## Running under: Ubuntu 22.04.5 LTS</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Matrix products: default</span></span>
<span><span class="co">## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 </span></span>
<span><span class="co">## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## locale:</span></span>
<span><span class="co">##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       </span></span>
<span><span class="co">##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   </span></span>
<span><span class="co">##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          </span></span>
<span><span class="co">## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## time zone: UTC</span></span>
<span><span class="co">## tzcode source: system (glibc)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## attached base packages:</span></span>
<span><span class="co">## [1] stats4    stats     graphics  grDevices utils     datasets  methods  </span></span>
<span><span class="co">## [8] base     </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## other attached packages:</span></span>
<span><span class="co">##  [1] scDblFinder_1.19.6          SingleCellExperiment_1.26.0</span></span>
<span><span class="co">##  [3] SummarizedExperiment_1.34.0 Biobase_2.64.0             </span></span>
<span><span class="co">##  [5] GenomicRanges_1.56.1        GenomeInfoDb_1.40.1        </span></span>
<span><span class="co">##  [7] IRanges_2.38.1              S4Vectors_0.42.1           </span></span>
<span><span class="co">##  [9] BiocGenerics_0.50.0         MatrixGenerics_1.16.0      </span></span>
<span><span class="co">## [11] matrixStats_1.4.1           BiocStyle_2.32.1           </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## loaded via a namespace (and not attached):</span></span>
<span><span class="co">##   [1] bitops_1.0-8              gridExtra_2.3            </span></span>
<span><span class="co">##   [3] rlang_1.1.4               magrittr_2.0.3           </span></span>
<span><span class="co">##   [5] scater_1.32.1             compiler_4.4.1           </span></span>
<span><span class="co">##   [7] DelayedMatrixStats_1.26.0 systemfonts_1.1.0        </span></span>
<span><span class="co">##   [9] vctrs_0.6.5               pkgconfig_2.0.3          </span></span>
<span><span class="co">##  [11] crayon_1.5.3              fastmap_1.2.0            </span></span>
<span><span class="co">##  [13] XVector_0.44.0            scuttle_1.14.0           </span></span>
<span><span class="co">##  [15] utf8_1.2.4                Rsamtools_2.20.0         </span></span>
<span><span class="co">##  [17] rmarkdown_2.28            UCSC.utils_1.0.0         </span></span>
<span><span class="co">##  [19] ggbeeswarm_0.7.2          ragg_1.3.3               </span></span>
<span><span class="co">##  [21] xfun_0.47                 bluster_1.14.0           </span></span>
<span><span class="co">##  [23] zlibbioc_1.50.0           cachem_1.1.0             </span></span>
<span><span class="co">##  [25] beachmat_2.20.0           jsonlite_1.8.8           </span></span>
<span><span class="co">##  [27] DelayedArray_0.30.1       BiocParallel_1.38.0      </span></span>
<span><span class="co">##  [29] irlba_2.3.5.1             parallel_4.4.1           </span></span>
<span><span class="co">##  [31] cluster_2.1.6             R6_2.5.1                 </span></span>
<span><span class="co">##  [33] bslib_0.8.0               limma_3.60.4             </span></span>
<span><span class="co">##  [35] rtracklayer_1.64.0        xgboost_1.7.8.1          </span></span>
<span><span class="co">##  [37] jquerylib_0.1.4           Rcpp_1.0.13              </span></span>
<span><span class="co">##  [39] bookdown_0.40             knitr_1.48               </span></span>
<span><span class="co">##  [41] Matrix_1.7-0              igraph_2.0.3             </span></span>
<span><span class="co">##  [43] tidyselect_1.2.1          abind_1.4-8              </span></span>
<span><span class="co">##  [45] yaml_2.3.10               viridis_0.6.5            </span></span>
<span><span class="co">##  [47] codetools_0.2-20          curl_5.2.2               </span></span>
<span><span class="co">##  [49] lattice_0.22-6            tibble_3.2.1             </span></span>
<span><span class="co">##  [51] evaluate_1.0.0            desc_1.4.3               </span></span>
<span><span class="co">##  [53] Biostrings_2.72.1         pillar_1.9.0             </span></span>
<span><span class="co">##  [55] BiocManager_1.30.25       generics_0.1.3           </span></span>
<span><span class="co">##  [57] RCurl_1.98-1.16           ggplot2_3.5.1            </span></span>
<span><span class="co">##  [59] sparseMatrixStats_1.16.0  munsell_0.5.1            </span></span>
<span><span class="co">##  [61] scales_1.3.0              glue_1.7.0               </span></span>
<span><span class="co">##  [63] metapod_1.12.0            tools_4.4.1              </span></span>
<span><span class="co">##  [65] BiocIO_1.14.0             data.table_1.16.0        </span></span>
<span><span class="co">##  [67] BiocNeighbors_1.22.0      ScaledMatrix_1.12.0      </span></span>
<span><span class="co">##  [69] locfit_1.5-9.10           GenomicAlignments_1.40.0 </span></span>
<span><span class="co">##  [71] fs_1.6.4                  scran_1.32.0             </span></span>
<span><span class="co">##  [73] XML_3.99-0.17             grid_4.4.1               </span></span>
<span><span class="co">##  [75] edgeR_4.2.1               colorspace_2.1-1         </span></span>
<span><span class="co">##  [77] GenomeInfoDbData_1.2.12   beeswarm_0.4.0           </span></span>
<span><span class="co">##  [79] BiocSingular_1.20.0       restfulr_0.0.15          </span></span>
<span><span class="co">##  [81] vipor_0.4.7               cli_3.6.3                </span></span>
<span><span class="co">##  [83] rsvd_1.0.5                textshaping_0.4.0        </span></span>
<span><span class="co">##  [85] fansi_1.0.6               S4Arrays_1.4.1           </span></span>
<span><span class="co">##  [87] viridisLite_0.4.2         dplyr_1.1.4              </span></span>
<span><span class="co">##  [89] gtable_0.3.5              sass_0.4.9               </span></span>
<span><span class="co">##  [91] digest_0.6.37             SparseArray_1.4.8        </span></span>
<span><span class="co">##  [93] ggrepel_0.9.6             dqrng_0.4.1              </span></span>
<span><span class="co">##  [95] rjson_0.2.23              htmltools_0.5.8.1        </span></span>
<span><span class="co">##  [97] pkgdown_2.1.1             lifecycle_1.0.4          </span></span>
<span><span class="co">##  [99] httr_1.4.7                statmod_1.5.0            </span></span>
<span><span class="co">## [101] MASS_7.3-60.2</span></span></code></pre>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Pierre-Luc Germain.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
